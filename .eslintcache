[{"C:\\wamp\\www\\settlerswarlords\\src\\reportWebVitals.js":"1","C:\\wamp\\www\\settlerswarlords\\src\\App.js":"2","C:\\wamp\\www\\settlerswarlords\\src\\DanInput.jsx":"3","C:\\wamp\\www\\settlerswarlords\\src\\comp_account.jsx":"4","C:\\wamp\\www\\settlerswarlords\\src\\comp_ErrorOverlay.jsx":"5","C:\\wamp\\www\\settlerswarlords\\src\\DanCommon.js":"6","C:\\wamp\\www\\settlerswarlords\\src\\comp_localMap.jsx":"7","C:\\wamp\\www\\settlerswarlords\\src\\comp_worldMap.jsx":"8","C:\\wamp\\www\\settlerswarlords\\src\\index.js":"9","C:\\wamp\\www\\settlerswarlords\\src\\comp_admin.jsx":"10","C:\\wamp\\www\\settlerswarlords\\src\\DanAjax.js":"11","C:\\wamp\\www\\settlerswarlords\\src\\block_leanto.jsx":"12","C:\\wamp\\www\\settlerswarlords\\src\\block_foragepost.jsx":"13","C:\\wamp\\www\\settlerswarlords\\src\\block_rockknapper.jsx":"14","C:\\wamp\\www\\settlerswarlords\\src\\block_toolbox.jsx":"15","C:\\wamp\\www\\settlerswarlords\\src\\game.jsx":"16","C:\\wamp\\www\\settlerswarlords\\src\\blockHasWorkerPriority.jsx":"17"},{"size":362,"mtime":1610251335559,"results":"18","hashOfConfig":"19"},{"size":20193,"mtime":1616381914017,"results":"20","hashOfConfig":"19"},{"size":2448,"mtime":1614382232549,"results":"21","hashOfConfig":"19"},{"size":8760,"mtime":1614301009043,"results":"22","hashOfConfig":"19"},{"size":2326,"mtime":1611446857039,"results":"23","hashOfConfig":"19"},{"size":2382,"mtime":1610580234395,"results":"24","hashOfConfig":"19"},{"size":10717,"mtime":1616365523744,"results":"25","hashOfConfig":"19"},{"size":24540,"mtime":1615046351441,"results":"26","hashOfConfig":"19"},{"size":500,"mtime":1610251335559,"results":"27","hashOfConfig":"19"},{"size":21163,"mtime":1614387900194,"results":"28","hashOfConfig":"19"},{"size":2141,"mtime":1611446941675,"results":"29","hashOfConfig":"19"},{"size":2652,"mtime":1616382181840,"results":"30","hashOfConfig":"19"},{"size":2198,"mtime":1616381645071,"results":"31","hashOfConfig":"19"},{"size":4493,"mtime":1616382199003,"results":"32","hashOfConfig":"19"},{"size":3152,"mtime":1616381744399,"results":"33","hashOfConfig":"19"},{"size":4451,"mtime":1616406137395,"results":"34","hashOfConfig":"19"},{"size":1981,"mtime":1616382119354,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"z4qb3y",{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"44"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"47"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"47"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"71","messages":"72","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\wamp\\www\\settlerswarlords\\src\\reportWebVitals.js",[],"C:\\wamp\\www\\settlerswarlords\\src\\App.js",[],"C:\\wamp\\www\\settlerswarlords\\src\\DanInput.jsx",[],"C:\\wamp\\www\\settlerswarlords\\src\\comp_account.jsx",[],["75","76"],"C:\\wamp\\www\\settlerswarlords\\src\\comp_ErrorOverlay.jsx",[],["77","78"],"C:\\wamp\\www\\settlerswarlords\\src\\DanCommon.js",[],"C:\\wamp\\www\\settlerswarlords\\src\\comp_localMap.jsx",["79","80"],"// component - LocalMap.jsx\r\n// Provides an interface for users to interact with the map local to where the player is located\r\n// for the game Settlers & Warlords\r\n\r\nimport React from \"react\";\r\nimport { imageURL, PageChoices, buildingList } from \"./App.js\";\r\nimport { LeanTo } from \"./block_leanto.jsx\";\r\nimport { ForagePost } from \"./block_foragepost.jsx\";\r\nimport { RockKnapper } from \"./block_rockknapper.jsx\";\r\nimport { Toolbox } from \"./block_toolbox.jsx\";\r\nimport {game} from \"./game.jsx\";\r\n//import { DAX } from \"./DanAjax.js\";\r\n//import { serverURL, imageURL, PageChoices, buildingList, gameLocalTiles } from \"./App.js\";\r\n//import { DanInput } from \"./DanInput.jsx\";\r\n//import { ErrorOverlay} from \"./comp_ErrorOverlay.jsx\";\r\n\r\nexport function localMap_fillFromServerData(mapContent) {\r\n    // Handles a bit of processing for the local map\r\n    // mapContent - data received from the server\r\n    // Returns an updated package of map content\r\n\r\n    return mapContent.map(tile => {\r\n        // Right now, we only need to make sure all tiles have a buildid field. Since we get no buildings from the server, this should be simple\r\n        tile.buildid = 0;\r\n        return tile;\r\n    });\r\n}\r\n\r\nexport function LocalMap(props) {\r\n    // Handles displaying local map content, along with buildings and their options on the right side\r\n    // prop fields - data\r\n    //      localTiles - All tiles of the local map\r\n    //      localStats - Additional information about this local map\r\n    // prop fields - functions\r\n    //      setPage      - handles changing the selected page. Only passed to TabPicker\r\n    //      onTileUpdate - handles any map tiles that have been updated\r\n\r\n    // minimap images could be global later, but for now we only need them here\r\n    const minimapImages = [\"emptygrass.jpg\", \"pinetreetwo.jpg\", \"basicrock.jpg\", \"desert.jpg\", \"smallpond.jpg\", \"basicrock.jpg\", \"basicore.jpg\"];\r\n    const [selected, setSelected] = React.useState(null); // which square is selected to show details on the right\r\n    const [scrollPos, setScrollPos] = React.useState({moveState:false,x:0,y:0});\r\n\r\n    function startPan() {\r\n        setScrollPos({...scrollPos, moveState:true});\r\n    }\r\n\r\n    function continuePan(e) {\r\n        if(!scrollPos.moveState) return;\r\n        setScrollPos({moveState:true, x:scrollPos.x+e.movementX, y:scrollPos.y+e.movementY});\r\n    }\r\n\r\n    function endPan() {\r\n        setScrollPos({...scrollPos, moveState:false});\r\n    }\r\n\r\n    function EmptyLandDescription() {\r\n        // Provides a basic description of the land on this selected tile\r\n        // landType - ID of the land type. This should be provided by props.landType\r\n\r\n        switch (selected.landtype) {\r\n            case 0: return <p>Grassland. Excellent for new construction and farming</p>;\r\n            case 1: return <p>Forest. Best source of wood and other materials</p>;\r\n            case 2: return <p>Barren rock. Easy source of stone materials and building on</p>;\r\n            case 3: return <p>Desert. Hot and hard to build on</p>;\r\n            case 4: return <p>Open water. A vital resource for life</p>;\r\n            case 5: return <p>Hot lava! Very dangerous, even from a distance</p>;\r\n            case 6: return <p>Slick ice. Very cold</p>;\r\n            case 7: return <p>Snowed-over ground. Very cold</p>;\r\n            default: return <p>Land type {props.landId} has not been coded yet</p>;\r\n        }\r\n    }\r\n\r\n    function placeBuilding(buildingName) {\r\n        // Check that we have a map tile selected, and that there is no building declared here\r\n        if(selected===null) return;\r\n        if(selected.buildid!==0) {\r\n            console.log('There is already building id='+ selected.buildid +' here');\r\n            return;\r\n        }\r\n        let b = {};\r\n        switch(buildingName) {\r\n            case 'leanto': b = LeanTo(selected); break;\r\n            case 'foragepost': b = ForagePost(selected); break;\r\n            case 'rockknapper': b = RockKnapper(selected); break;\r\n            case 'toolbox': b = Toolbox(selected); break;\r\n        }\r\n        if(typeof(b)==='string') {\r\n            console.log('Building placement failed: '+ b);\r\n            return;\r\n        }\r\n        game.blocks.push(b);\r\n        \r\n        // We also need to update the local tiles; updating `selected` won't work here\r\n        let tile = game.tiles.findIndex(ele=>ele.x===selected.x && ele.y===selected.y);\r\n        game.tiles[tile].buildid = b.id;\r\n\r\n        // Update the specific tile. We already have a function to help us do that; it accepts any number of updated tiles,\r\n        // swapping out any based on X&Y coordinates\r\n        props.onTileUpdate([{...selected, buildid:b.id, buildimage:b.image}]);\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <div style={{display:'flex', width:'100%'}}>\r\n                <div>\r\n                    <span className=\"haslinespacing\">Biome: {props.localStats.biome}</span>\r\n                    <span className=\"haslinespacing\">Population: {props.localStats.population}</span>\r\n                    <PageChoices selected={\"localmap\"} onPagePick={props.setPage} />\r\n                </div>\r\n            </div>\r\n            <div style={{display:'flex', width:'100%'}}>\r\n                <div style={{width:180}}>\r\n                    <img src={imageURL +'leanto.png'} alt=\"leanto\" onClick={()=>placeBuilding('leanto')}/>\r\n                    <img src={imageURL +'foragepost.png'} alt=\"forage post\" onClick={()=>placeBuilding('foragepost')}/>\r\n                    <img src={imageURL +'rockKnapper.png'} alt=\"rock knapper\" onClick={()=>placeBuilding('rockknapper')}/>\r\n                    <img src={imageURL +'toolbox.png'} alt=\"toolbox\" onClick={()=>placeBuilding('toolbox')}/>\r\n                </div>\r\n                <div id=\"localmapbox\">\r\n                    {/* This is the map container, that helps us scroll the whole map at once */}\r\n                    <div\r\n                        style={{position:'absolute', top:scrollPos.y, left:scrollPos.x}}\r\n                        onMouseDown={startPan}\r\n                        onMouseMove={continuePan}\r\n                        onMouseUp={endPan}\r\n                    >\r\n                        {props.localTiles.map((tile, key) => {\r\n                            return (\r\n                                <div\r\n                                    style={{\r\n                                        display: \"block\",\r\n                                        position: \"absolute\",\r\n                                        width: 55,\r\n                                        height: 55,\r\n                                        top: tile.y * 57,\r\n                                        left: tile.x * 57,\r\n                                        backgroundImage: \"url(\" + imageURL + minimapImages[tile.landtype] + \")\",\r\n                                        backgroundColor: 'green',\r\n                                        cursor: \"pointer\",\r\n                                        border: (tile===selected)?'1px solid black':'1px solid green'\r\n                                    }}\r\n                                    key={key}\r\n                                    onClick={() => setSelected(tile)}\r\n                                >\r\n                                    {parseInt(tile.buildid) === 0 ? (\r\n                                        \"\"\r\n                                    ) : (\r\n                                        <>\r\n                                            <img src={tile.buildimage} alt={\"building\"} style={{ pointerEvents: \"none\", border:0 }} draggable=\"false\"/>\r\n                                            {typeof(tile.progressBar)==='undefined'? (''):\r\n                                                <div style={{\r\n                                                    backgroundColor: tile.progressBarColor,\r\n                                                    bottom:0,\r\n                                                    height:20,\r\n                                                    width:tile.progressBar\r\n                                                }}></div>\r\n                                            }\r\n                                        </>\r\n                                    )}\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </div>\r\n                </div>\r\n                <div id=\"localmaprightpane\">\r\n                    {selected === null ? (\r\n                        \"Click a tile to view options\"\r\n                    ) : parseInt(selected.buildid) === 0 ? (\r\n                        <>\r\n                            {EmptyLandDescription()}\r\n                            <p className=\"singleline\">Nothing is built here. Select a block from the left to place it here</p>\r\n                        </>\r\n                    ) : (\r\n                        <LocalTileBuildingDetail tile={selected} />\r\n                    )}\r\n                </div>\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nfunction LocalTileBuildingDetail(props) {\r\n    // Shows cnotent on the right about the selected building.\r\n    // Components that use this component: LocalMap\r\n    // prop fields - data\r\n    //     tile - object containing all the data about the building to show\r\n    // prop fields - functions\r\n    //      onTileUpdate - Allows a single map tile to be updated\r\n    \r\n    let block = game.blocks.find(ele=>ele.id===props.tile.buildid);\r\n    if(typeof(block)==='undefined') return <>Block not found by id</>;\r\n\r\n    return <>\r\n        <div style={{width:'100%', align:'center'}}>{block.name}</div>\r\n        <p>{block.descr}</p>\r\n        <p>{block.usage}</p>\r\n        {block.SidePanel()}\r\n    </>;\r\n}\r\n\r\nexport function ClickableLabel(props) {\r\n    // Provides a clickable label with multiple modes that can be swappd at will\r\n    // prop fields - data\r\n    //      mode - which mode to display\r\n    //      options: list of selectable modes, each containing properties:\r\n    //          name: name matching the value of 'mode'\r\n    //          bgColor: Color of the background\r\n    // prop fields - functions\r\n    //      onClick: action to take when the user clicks the box\r\n\r\n    // Pick out the correct element. If the element isn't found, pick the last one\r\n    let picked = props.options.find(e=>e.name===props.mode);\r\n    if(typeof(picked)==='undefined') picked = props.options[0];\r\n\r\n    return (\r\n        <span\r\n            style={{margin:1, padding:10, backgroundColor:picked.bgColor, cursor:'pointer', border:'1px black solid', display:'inline-block'}}\r\n            onClick={()=>props.onClick(props.mode)}\r\n        >\r\n            {props.children}\r\n        </span>\r\n    );\r\n}\r\n","C:\\wamp\\www\\settlerswarlords\\src\\comp_worldMap.jsx",["81","82","83"],"/*\r\n    comp_worldMap.jsx\r\n    Contains React components and other objects related to the world map\r\n    For the game Settlers & Warlords\r\n*/\r\n\r\nimport React from \"react\";\r\n\r\nimport { DAX } from \"./DanAjax.js\";\r\nimport { DanCommon } from \"./DanCommon.js\";\r\nimport { DanInput } from \"./DanInput.jsx\";\r\n\r\nimport { serverURL, imageURL, PageChoices } from \"./App.js\";\r\n\r\nconst worldMapTile = [\r\n    { biome: 0, name: \"Grassland\", image: \"worldgrass.png\", desc: \"Open fields of grass. A ripe place to grow crops\" },\r\n    { biome: 1, name: \"Forest\", image: \"worldforest.png\", desc: \"Tall trees and dense brush. An excellent source of lumber\" },\r\n    { biome: 2, name: \"Desert\", image: \"worlddesert.png\", desc: \"Hot and dusty lands. Resources are scarce, but land is cheap\" },\r\n    { biome: 3, name: \"Swamp\", image: \"worldswamp.png\", desc: \"Wet marsh and lakes. Structures are unstable, travel is difficult\" },\r\n    { biome: 4, name: \"Water\", image: \"worldwater.png\", desc: \"Water as far as can be seen. Many things exist under the surf\" },\r\n    { biome: 5, name: \"Jungle\", image: \"worldjungle.png\", desc: \"Tall trees in hot and humid lands. Life is plentiful but hostile\" },\r\n    { biome: 6, name: \"Lavascape\", image: \"worldlava.png\", desc: \"Lava and rock, too hot for anything. Not a good place to be!\" },\r\n    { biome: 7, name: \"Frozen Waste\", image: \"worldfrozen.png\", desc: \"Snow and ice, nothing but cold. Not a good place to be!\" },\r\n    { biome: 8, name: \"Exploring\", image: \"worldexploring.png\", desc: \"Travellers have been sent to see what's there\" },\r\n    { biome: 9, name: \"Unexplored Land\", image: \"worldunseen.png\", desc: \"Nothing is known of this area\" },\r\n];\r\n\r\n// A simple array containing cardinal directions, for additional uses\r\nexport const cardinalDirections = [\r\n    { x: 0, y: -1 },\r\n    { x: 1, y: 0 },\r\n    { x: 0, y: 1 },\r\n    { x: -1, y: 0 },\r\n];\r\n\r\nfunction manDist(x1, y1, x2, y2) {\r\n    // Returns a manhattan distance between two points. This is useful in a cardinal-direction map, and is faster\r\n    // than calculating a bee-line distance\r\n    return Math.abs(x1 - x2) + Math.abs(y1 - y2);\r\n}\r\n\r\nexport function worldMap_fillFromServerData(data, userId) {\r\n    // Manages filling in the world map data that is received from the server. THe server will supply all the real tiles, but unexplored\r\n    // tiles need to be displayed as well. This adds those as existing tiles, even though they aren't real\r\n    // data - data package that is received from the server\r\n    // Returns a new instance of the world map structure. This can be passed to the React hook\r\n\r\n    // Mark any lands as conquerable or not. Players can only conquer lands that are adjacent to their own land\r\n    // (firstly; there may be more requirements later)\r\n    // While here, also set colors of certain tiles, based on which player owns them. The map tiles will be in the order of discovery,\r\n    // making the player's own lands first (and therefore, blue)\r\n    const tileColorList = ['blue','orange','green','brown','slate','white','red','black','yellow','violet','rose','aqua'];\r\n    let foundOwners = [];\r\n    data.worldmap = data.worldmap.map(ele => {\r\n        ele.canConquer = cardinalDirections.some(adjust => {\r\n            // Find the tile for this adjusted location\r\n            let neighbor = data.worldmap.find(inner =>\r\n                (parseInt(ele.x)+adjust.x === parseInt(inner.x) && parseInt(ele.y)+adjust.y === parseInt(inner.y)));\r\n            if(neighbor==null) return false;\r\n            console.log('compare '+ neighbor.owner +' vs '+ userId);\r\n            return neighbor.owner===userId;\r\n        });\r\n\r\n        if(ele.owner!=0) {\r\n            let slot = foundOwners.findIndex(red=>red===ele.owner);\r\n            if(slot===-1) {\r\n                // This is a new listing. Push a new owner ID to the list\r\n                foundOwners.push(ele.owner);\r\n                ele.tileColor = tileColorList[(foundOwners.length-1)%12];\r\n            }else{\r\n                ele.tileColor = tileColorList[slot%12];\r\n            }\r\n        }\r\n        return ele;\r\n    });\r\n\r\n    let addons = data.worldmap.map(ele => {\r\n        // if this is a 'pending exploration' tile, we don't need to 'explode' it\r\n        if(ele.biome===worldMapTile.length-2) {\r\n            return undefined;\r\n        }\r\n        return cardinalDirections.map(adjust => {\r\n            // Determine if any of the adjacent world map blocks exist\r\n            if(data.worldmap.some(inner => (parseInt(ele.x)+adjust.x === parseInt(inner.x) && parseInt(ele.y)+adjust.y === parseInt(inner.y)))) {\r\n                // There is already a tile here. Return undefined. We can remove this later\r\n                return undefined;\r\n            }\r\n            // Since there's no tile here, create one\r\n            return {\r\n                x: parseInt(ele.x)+adjust.x,\r\n                y: parseInt(ele.y)+adjust.y,\r\n                biome: worldMapTile[worldMapTile.length-1].biome,\r\n                civ:-1,\r\n                owner:0,\r\n                canConquer:false\r\n            };\r\n        });\r\n    });\r\n    // That creates a 2D array, but we need to flatten it\r\n    addons = DanCommon.flatten(addons).filter(check => {\r\n        // Remove any results that came back as undefined\r\n        // We would have done this earlier, but need to also remove tiles we won't search around (because they're actively being explored)\r\n        return check !== undefined;\r\n    });\r\n\r\n    // We still have to remove duplicates from our addons list. Converting this to a set & back only works for primitives. We will use a\r\n    // different method\r\n    let filtered = [];\r\n    addons.forEach(ele => {\r\n        if(!filtered.some(find => ele.x===find.x && ele.y===find.y)) {\r\n            filtered.push(ele);\r\n        }\r\n    });\r\n\r\n    // Now we have all the new tiles we need. Return it with the existing tiles\r\n    return [...data.worldmap, ...filtered];\r\n}\r\n\r\nexport function WorldMap(props) {\r\n    // Handles displaying the world, as the user understands it\r\n    // prop fields - data\r\n    //      worldMap - list of objects, each is information about a world map tile\r\n    //      specifics - object holding specific details: current player coordinates, and user's ID (to compare against a tile's owner)\r\n    //      localItems - list of all items (with quantities) of what is available at the player's current location\r\n    // prop fields - functions\r\n    //      setPage - Allows the user to switch which page they are looking at\r\n    //      changeWorldMap - React updater function to update the contents of the world map\r\n    //      startWorldAction - called when the user chooses to send units to another world map tile. Parameters\r\n    //          x, y - world coordinates to send the units to\r\n    //          action - what action to take for that land\r\n    //          travellers - how many units are heading there\r\n\r\n    const [pickedTile, setPickedTile] = React.useState(null);\r\n    const [scrollPos, setScrollPos] = React.useState({moveState:false,x:0,y:0});\r\n    //console.log(props.worldMap);\r\n\r\n    function changeMapTile(newTile) {\r\n        // Allows a single world map tile to be inserted into the existing world map\r\n        props.changeWorldMap(props.worldMap.map(ele => {\r\n            if(ele.x===newTile.x && ele.y===newTile.y) {\r\n                return newTile;\r\n            }\r\n            return ele;\r\n        }));\r\n    }\r\n\r\n    function startPan() {\r\n        setScrollPos({...scrollPos, moveState:true});\r\n    }\r\n\r\n    function continuePan(e) {\r\n        if(!scrollPos.moveState) return;\r\n        setScrollPos({moveState:true, x:scrollPos.x+e.movementX, y:scrollPos.y+e.movementY});\r\n    }\r\n\r\n    function endPan() {\r\n        setScrollPos({...scrollPos, moveState:false});\r\n    }\r\n\r\n    // blue orange green brown slate white red black yellow violet rose aqua\r\n\r\n    return (\r\n        <div\r\n            style={{\r\n                width: \"100%\",\r\n                height: window.innerHeight - 170,\r\n                position: \"relative\",\r\n                overflow: \"hidden\",\r\n            }}>\r\n            <div style={{position:'relative', zIndex:'1', backgroundColor:'white'}}>\r\n                <PageChoices selected={\"worldmap\"} onPagePick={props.setPage} />\r\n            </div>\r\n            \r\n            {/* Now to display the map */}\r\n            <div\r\n                style={{width:\"100%\", height:window.innerHeight-170, position:'relative', left:scrollPos.x, top:scrollPos.y}}\r\n                onMouseDown={startPan}\r\n                onMouseMove={continuePan}\r\n                onMouseUp={endPan}\r\n                >\r\n                {props.worldMap.map((ele, key) => (\r\n                    <div\r\n                        key={key}\r\n                        className=\"worldmaptile\"\r\n                        \r\n                        style={{\r\n                            top: (ele.y - props.specifics.cury) * 55 + (window.innerHeight - 170) / 2,\r\n                            left: (ele.x - props.specifics.curx) * 55 + window.innerWidth / 2,\r\n                            border: (ele.owner===0?'0px':'1px solid '+ ele.tileColor)\r\n                        }}\r\n                    >\r\n                        <img\r\n                            draggable=\"false\" // this can only be applied to the image tag, nothing else\r\n                            src={imageURL + worldMapTile[ele.biome].image}\r\n                            onClick={() => {\r\n                                setPickedTile(ele);\r\n                            }}\r\n                            alt=\"land\"\r\n                            onMouseDown={startPan}\r\n                            onMouseMove={continuePan}\r\n                            onMouseUp={endPan}\r\n                        />\r\n                        {ele.x === props.specifics.curx && ele.y === props.specifics.cury ? (\r\n                            <img\r\n                                className=\"worldmaptileimageoverlay\"\r\n                                src={imageURL + \"youarehere.png\"}\r\n                                alt=\"you are here\"\r\n                            />\r\n                        ) : \r\n                            // Show the civilization type on top, if one exists here\r\n                            ele.civ===-1?(''):ele.civ.image===''?(''):(\r\n                                <img\r\n                                    className=\"worldmaptileimageoverlay\"\r\n                                    src={imageURL+ele.civ.image}\r\n                                    alt={ele.civ.name}\r\n                                />\r\n                            )\r\n                        }\r\n                    </div>\r\n                ))}\r\n                {/* Now, show the selected tile, if any is picked */}\r\n                {pickedTile === null ? (\r\n                    \"\"\r\n                ) : (\r\n                    <WorldTileDetail\r\n                        tile={pickedTile}\r\n                        curDetails={props.specifics}\r\n                        onClose={() => setPickedTile(null)}\r\n                        changeMapTile={changeMapTile}\r\n                        localItems={props.localItems}\r\n                    />\r\n                )}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction WorldTileDetail(props) {\r\n    // Displays detailed information about a specific world map tile selected\r\n    // prop fields - data\r\n    //      tile - details about the selected tile\r\n    //      curDetails - Information about the place that the user is currently at\r\n    //      localItems - List of all items at the player's current location\r\n    // prop fields - functions\r\n    //      onClose - action to take when the X button for closing the pop-up window is clicked\r\n    //      changeMapTile - Allows a single map tile to be replaced, triggering a full React re-render\r\n\r\n    const [action, setAction] = React.useState(\"\"); // The selected action to show details on\r\n\r\n    // When another tile is selected, update the interface\r\n    React.useEffect(()=> {\r\n        return ()=>{ setAction(\"\"); };\r\n    }, [props.tile]);\r\n\r\n    function showOptions() {\r\n        // Shows user actions based on the type of land selected\r\n\r\n        if(props.tile.biome===worldMapTile[worldMapTile.length-1].biome) {\r\n            // This area is not explored yet. Allow the area to be explored\r\n            return (\r\n                <>\r\n                    <p className={\"singleline\"}>You must explore a land first</p>\r\n                    <p className={\"fakelink singleline\"} onClick={()=>setAction('expedition')}>Send Expedition</p>\r\n                </>\r\n            );\r\n        }\r\n        if(props.tile.biome===worldMapTile[worldMapTile.length-2].biome) {\r\n            // The user is already exploring this area\r\n            return <p>We will decide what to do when they have returned</p>;\r\n        }\r\n        if(props.tile.civ===-1 && props.tile.owner===0 && props.tile.canConquer) {\r\n            // Nobody owns this land. Allow the player to conquer it\r\n            console.log(props.tile.canConquer);\r\n            return (\r\n                <>\r\n                    <p className=\"singleline\">Nobody owns this land.</p>\r\n                    <p className=\"singleline fakelink\" onClick={()=>setAction('settle')}>Settle lands</p>\r\n                    <p className=\"singleline fakelink\" onClick={()=>setAction('gather')}>Gather resources</p>\r\n                </>\r\n            );\r\n        }\r\n        return <p className=\"singleline\">This needs coded</p>;\r\n    }\r\n\r\n    function startWorldAction(travellers, itemsList, startActions) {\r\n        // Handles setting up a world action to take place\r\n        // travellers - number of colony units being sent. Minimum is 1\r\n        // itemsList - array of all items being taken on this journey\r\n        // startActions - object with properties specific to settling new lands. So far we only have forage:t/f or leantos:t/f\r\n        // The world coordinates for this action is determined by props.tile\r\n        // The action used is determined by the React state named action\r\n\r\n        if(props.tile===null) {\r\n            console.log('Error - called startWorldAction() while props.tile is not set. No action taken');\r\n            return;\r\n        }\r\n        let pkg = { x: props.tile.x, y: props.tile.y, command: action, members: travellers, items:itemsList };\r\n        if(action==='settle') {\r\n            pkg.forage = startActions.forage?'true':'false';\r\n            pkg.leantos = startActions.leantos?'true':'false';\r\n        }\r\n        fetch(serverURL, DAX.serverMessage(\"startworldaction\", pkg, true))\r\n            .then((res) => DAX.manageResponseConversion(res))\r\n            .catch((err) => console.log(err))\r\n            .then((data) => {\r\n                if(data.result!=='success') {\r\n                    console.log('Server reported error:', data);\r\n                    return;\r\n                }\r\n                // While we should have received a tag to determine when to fetch data from the server again, our main concern now is\r\n                // to update the selected tile on the map\r\n                let working = props.tile;\r\n                working.biome = worldMapTile.length-2;\r\n                props.changeMapTile(working);\r\n                props.onClose();\r\n            });\r\n    }\r\n\r\n    return (\r\n        <div className=\"worldmaptiledetailbox\"\r\n            style={{\r\n                top: (1+props.tile.y - props.curDetails.cury) * 55 + (window.innerHeight - 170) / 2,\r\n                left: (props.tile.x - props.curDetails.curx) * 55 + window.innerWidth / 2,\r\n            }}\r\n        >\r\n            {/* Start with the X close button at the top right */}\r\n            <img className=\"exitbutton\" src={imageURL + \"exit.png\"} onClick={props.onClose} alt={\"eXit\"} />\r\n\r\n            {/* Show some basic data of this land, including inhabitants */}\r\n            <div style={{textAlign: 'center'}}>\r\n                {props.tile.civ===-1?(\r\n                    <div>\r\n                        <p className=\"singleline\" style={{fontWeight:'bold'}}>\r\n                            {worldMapTile[props.tile.biome].name}\r\n                        </p>\r\n                        <p>{worldMapTile[props.tile.biome].desc}</p>\r\n                    </div>\r\n                ):(\r\n                    <div>\r\n                        <p className=\"singleline\" style={{fontWeight:'bold'}}>\r\n                            {props.tile.civ.name}\r\n                        </p>\r\n                        <p>{props.tile.civ.desc}</p>\r\n                    </div>\r\n                )}\r\n            </div>\r\n\r\n            {/* Show some actions the user can do with this land */}\r\n            {action === \"\" ? (\r\n                showOptions()\r\n            ) : (\r\n                <WorldActionDetail\r\n                    choice={action}\r\n                    distance={manDist(props.tile.x, props.tile.y, props.curDetails.curx, props.curDetails.cury)}\r\n                    startWorldAction={startWorldAction}\r\n                    localItems={props.localItems}\r\n                />\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction WorldActionDetail(props) {\r\n    // Displays details about the selected action on the world map.\r\n    // prop fields - data\r\n    //      choice - which action they chose to view details of\r\n    //      distance - distance from the current location this is\r\n    //      localItems - list of all items the player currently has at this location\r\n    // prop fields - functions\r\n    //      startWorldAction - called when the user chooses to start the selected action. parameters:\r\n    //          1 (required): number of colonists being used for this action\r\n    //          2 (required): List of items the colonists will take with them. This will include at least some amount of food, selected by the user\r\n    //          3 (required): List of properties to include, exclusive to settling new lands. So far we only have forage:t/f and leantos:t/f\r\n\r\n    const [numTravellers, setNumTravellers] = React.useState(props.choice==='settle'?4:1);\r\n    const [pickedItems, setPickedItems] = React.useState([]);\r\n    const [itemChoices, setItemChoices] = React.useState([]);\r\n    const [startActions, setStartActions] = React.useState({forage:false, leantos:false});\r\n\r\n    //console.log(props.localItems);\r\n\r\n    function capacity() {\r\n        // Calculates the remaining capacity of the party. This is used more than once\r\n        let carrying = pickedItems.reduce((carry,ele)=>{\r\n            // Add special cases for carrying items, such as satchels. This may make our number negative, but it's not a problem\r\n            if(ele.name==='Satchel') return carry-ele.amount*20;\r\n\r\n            return carry+ele.amount\r\n        },0);\r\n        return numTravellers*3-carrying\r\n    }\r\n\r\n    function addItem(newItem) {\r\n        // If there's nothing in the list, create the first element\r\n        if(pickedItems.length===0) {\r\n            setPickedItems([{name:newItem.name, amount:1, isFood:newItem.isFood}]);\r\n            return;\r\n        }\r\n        // First, determine if this item is in the list already\r\n        let slot = pickedItems.findIndex(e=>e.name===newItem.name);\r\n        let list = pickedItems;\r\n        if(slot===-1) {\r\n            list.push({name:newItem.name, amount:1, isFood:newItem.isFood});\r\n        }else{\r\n            list[slot].amount++;\r\n        }\r\n        setPickedItems(list);\r\n    }\r\n\r\n    function foodNeeded() {\r\n        // Returns how much food is needed for the trip. This is used more than once\r\n        if(props.choice==='settle') {\r\n            return props.distance * numTravellers;\r\n        }\r\n        return props.distance * 2 * numTravellers;\r\n    }\r\n\r\n    function foodItems() {\r\n        // Returns the total food that has been selected for this journey\r\n        // Since we happen to have isFood stored as 0 or 1, we can just add it up!\r\n        let result = pickedItems.reduce((carry,item)=>{ return carry+item.isFood*item.amount;},0);\r\n        console.log(result);\r\n        return result;\r\n    }\r\n\r\n    function displayPrompt() {\r\n        // Shows the correct prompt, based on what action was selected (in props)\r\n        switch(props.choice) {\r\n            case 'expedition': return <p>Send people to explore new lands, and determine its inhabitants</p>;\r\n            case 'settle':     return <p>Settle a land to expand your kingdom</p>;\r\n            case 'gather':     return <p>Send people to gather resources at remote locations</p>;\r\n        }\r\n    }\r\n    \r\n    // Generally, it will take 5 minutes to walk between each world tile\r\n    // Food is also consumed at a rate of 1 every 5 minutes, per colonist\r\n    return (\r\n        <div>\r\n            {displayPrompt()}\r\n            <p className=\"singleline\">\r\n                Distance: {props.distance}\r\n                <span style={{ marginLeft: 30 }}></span>\r\n                Time to return: {props.distance * 10} minutes\r\n            </p>\r\n            <p className=\"singleline\">\r\n                <DanInput placeholder=\"travellers - min 1\" onUpdate={(f, v) => setNumTravellers(v)} default={numTravellers} />\r\n            </p>\r\n            <span style={{fontWeight:'bold'}}>Load</span> (capacity {capacity()})\r\n            {pickedItems.map((ele,key) => (\r\n                <div key={key}>\r\n                    {ele.name} x {ele.amount +\" \"}\r\n                    <span style={{fontWeight:'bold', cursor:'pointer', marginRight:7}} onClick={()=>{\r\n                        if(capacity()<=0) return;\r\n                        setPickedItems(pickedItems.map(fin=>{\r\n                            if(fin.name===ele.name) fin.amount++;\r\n                            return fin;\r\n                        }));\r\n                    }}>+</span>\r\n                    {\" \"}\r\n                    <span style={{fontWeight:'bold', cursor:'pointer', marginRight:7}} onClick={()=>{\r\n                        if(ele.amount===1) {\r\n                            // reducing will make this zero. We want to remove this, not adjust it\r\n                            setPickedItems(pickedItems.filter(fin=>fin.name!==ele.name));\r\n                        }else{\r\n                            setPickedItems(pickedItems.map(fin=>{\r\n                                if(fin.name===ele.name) fin.amount--;\r\n                                return fin;\r\n                            }));\r\n                        }\r\n                    }}>-</span>\r\n                    {\" \"}\r\n                    <span style={{fontWeight:'bold', cursor:'pointer'}} onClick={()=>setPickedItems(pickedItems.filter(f=>f.name!==ele.name))}>\r\n                        X\r\n                    </span>\r\n                </div>\r\n            ))}\r\n            <p className=\"singleline\" style={{whiteSpace:'no-wrap'}}>\r\n                <DanInput\r\n                    placeholder=\"Type to search\"\r\n                    onUpdate={(f,v)=>{\r\n                        // Create a list of all items that contain this string\r\n                        setItemChoices(props.localItems.filter(ele => ele.name.toLowerCase().includes(v.toLowerCase())));\r\n                    }}\r\n                />\r\n            </p>\r\n            {itemChoices.map((ele,key)=> (\r\n                <div key={key}>\r\n                    <span className=\"fakelink\" style={{marginRight:5}} onClick={()=>addItem(ele)}>\r\n                        {ele.name}\r\n                    </span>\r\n                    (have {Math.floor(ele.amount)})\r\n                </div>\r\n            ))}\r\n            <p className=\"singleline\">\r\n                <button\r\n                    onClick={() => props.startWorldAction(numTravellers, pickedItems, startActions)}\r\n                    disabled={(foodNeeded()>foodItems())?true:false}\r\n                >\r\n                    Start\r\n                </button>\r\n            </p>\r\n            Journey requires {foodNeeded()} food\r\n\r\n            {props.choice!='settle'?(\r\n                ''\r\n            ):(\r\n                <>\r\n                    <p className=\"singleline\" style={{fontWeight:'bold'}}>Starting actions</p>\r\n                    <p className=\"singleline\">\r\n                        <input type=\"checkbox\" onChange={()=>setStartActions({...startActions, forage:!startActions.forage})} />\r\n                        Forage for food\r\n                    </p>\r\n                    <p className=\"singleline\">\r\n                        <input type=\"checkbox\" onChange={()=>setStartActions({...startActions, leantos:!startActions.leantos})} />\r\n                        Build lean-tos for settlers\r\n                    </p>\r\n                </>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n","C:\\wamp\\www\\settlerswarlords\\src\\index.js",[],"C:\\wamp\\www\\settlerswarlords\\src\\comp_admin.jsx",["84","85"],"/* comp_admin.jsx\r\n    handles all React components related to the admin portion of this project\r\n    for the game Settlers & Warlords\r\n*/\r\n\r\nimport React from \"react\";\r\nimport {DanInput} from \"./DanInput.jsx\";\r\nimport {DAX} from \"./DanAjax.js\";\r\n\r\nimport {serverURL} from \"./App.js\";\r\n\r\nexport function AdminPage(props) {\r\n    // Handles all the admin sections\r\n    // prop fields - data\r\n    //      buildings - list of buildings and all the data relevant to it\r\n    // prop fields - functions\r\n    //      changeBuildingList - React updater function to alter the buildings list\r\n\r\n    const [selectedBuilding, setSelectedBuilding] = React.useState({});\r\n\r\n    function changeSingleBuilding(newBuildingData) {\r\n        // Allows a single building to be updated. We can still process building updates deeper than this, but the actual buildings list\r\n        // stops here. So to update the full buildings list, we swap out the new building data with the matching one in the existing list\r\n\r\n        props.changeBuildingList(props.buildings.map(build => {\r\n            if(build.name===newBuildingData.name) {\r\n                return newBuildingData;\r\n            }\r\n            return build;\r\n        }));\r\n    }\r\n\r\n    // Here, our objective is to display all buildings. We will show details to the selected building\r\n    return (\r\n        <div>\r\n            {props.buildings.map((ele, key) => {\r\n                if(ele===selectedBuilding) {\r\n                    return (\r\n                        <AdminBuilding\r\n                            key={key}\r\n                            building={ele}\r\n                            changeSingleBuilding={changeSingleBuilding}\r\n                        />\r\n                    );\r\n                }else{\r\n                    // Display this as normal\r\n                    return (\r\n                        <div key={key} style={{margin:5, border:\"1px black solid\", cursor:'pointer'}} onClick={()=>setSelectedBuilding(ele)}>\r\n                            {ele.name}\r\n                        </div>\r\n                    );\r\n                }\r\n            })}\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction AdminBuilding(props) {\r\n    // Displays information about a single building, for the admin to edit\r\n    // prop fields - data\r\n    //      building - full data structure for this one building, including actions and their items\r\n    // prop fields - functions\r\n    //      changeSingleBuilding - Allows the full building list to be updated\r\n    \r\n    // There's a few changes this time around\r\n    // 1) Building fortification levels will be separate from production levels; they won't have a direct correlation. Therefore, we don't\r\n    //      need to consider them in how the buildings upgrade\r\n    // 2) The actions of an item are organized differently, being stored as a JSON object instead of as separate records in the database\r\n\r\n    const [selectedLevel, setSelectedLevel] = React.useState(1);\r\n    const [description, setDescription] = React.useState(props.building.description);\r\n    const [levelMinWorkers, setLevelMinWorkers] = React.useState(props.building.levels[selectedLevel-1].minworkers);\r\n    const [levelMaxWorkers, setLevelMaxWorkers] = React.useState(props.building.levels[selectedLevel-1].maxworkers);\r\n    const [newActionName, setNewActionName] = React.useState('');\r\n    const [actionMinWorkers, setActionMinWorkers] = React.useState(1);\r\n    \r\n    const [selectedAction, setSelectedAction] = React.useState(null);\r\n\r\n    console.log(props.building);\r\n\r\n    function addNewLevel() {\r\n        console.log('Time to add a new level!');\r\n    }\r\n\r\n    function saveLevelStats(target, value) {\r\n        console.log('Set '+ target +' to '+ value);\r\n    }\r\n\r\n    function changeLevel(newLevel) {\r\n        setSelectedLevel(newLevel);\r\n        setLevelMinWorkers(props.building.levels[newLevel-1].minworkers);\r\n        setLevelMaxWorkers(props.building.levels[newLevel-1].maxworkers);\r\n    }\r\n\r\n    function addNewAction(newName) {\r\n        // Allows the user to add a new action to this selected building\r\n\r\n        // We will handle server contact here\r\n        fetch(serverURL, DAX.serverMessage(\"adminAddBuildingAction\", {buildname: props.building.name, actionname: newName}, true))\r\n            .then(res => DAX.manageResponseConversion(res))\r\n            .catch(err => console.log('message conversion failure', err))\r\n            .then(data => {\r\n                if(data.result !== \"success\") {\r\n                    console.log(\"Server reports failure:\", data);\r\n                    return;\r\n                }\r\n                \r\n                // Now update the buildings. We were going to haul the function changeBuildingList all the way here, but we don't have\r\n                // (or need) the full list of buildings. So, we have a convenient update function in AdminBuildings we can use instead.\r\n                let workBuilding = props.building;\r\n                workBuilding.actions.push({\r\n                    name: newName,\r\n                    inputGroup: [],\r\n                    outputGroup: [],\r\n                    minLevel: 1,\r\n                    minWorkers: 1,\r\n                    maxWorkers: 1,\r\n                });\r\n                props.changeSingleBuilding(workBuilding);\r\n            });\r\n    }\r\n\r\n    /* So, we can't really use this; sending data to the server requires us to have the building name,a nd so we might as well\r\n    update actions here, instead of within the AdminActions component\r\n    function changeAction(newActionData) {\r\n        // Allows a specific action of this building to be changed\r\n        \r\n        // Find the action instance in the building, and trigger it to be changed\r\n        let workBuilding = props.building\r\n        workBuilding.actions = workBuilding.actions.map(action => {\r\n            if(action.name===newActionData.name) {\r\n                return newActionData;\r\n            }\r\n            return action;\r\n        });\r\n        props.changeSingleBuilding(workBuilding);\r\n    }//*/\r\n\r\n    function changeActionItems(actionName, side, field, itemName, val) {\r\n        // Changes the items for a specific action\r\n        // actionName - name of the action that needs updating\r\n        // side - use 'input' or 'output' to pick whether this is part of the input group or output group\r\n        // field - use 'name' or 'amount'\r\n        // itemName - name of the item to be updated\r\n        // value - new value, whether it is the name or amount\r\n        // No return value\r\n\r\n        // Even though value can be either an int or string, the server can manage either case\r\n        fetch(serverURL, DAX.serverMessage(\"adminChangeActionItem\", {buildname: props.building.name, actionname: actionName, side:side, part:field, name:itemName, newvalue:val}, true))\r\n            .then(res => DAX.manageResponseConversion(res))\r\n            .catch(err => console.log('response conversion failure:', err))\r\n            .then(data => {\r\n                if(data.result !== 'success') {\r\n                    console.log('Server reported failure:', data);\r\n                    return;\r\n                }\r\n                // Generate a new building, and update its actions\r\n                let workBuilding = props.building;\r\n                workBuilding.actions = workBuilding.actions.map(action => {\r\n                    if(action.name===actionName) {\r\n                        // Now, find the correct item to update\r\n                        if(side === 'input') {\r\n                            action.inputGroup = action.inputGroup.map(item => {\r\n                                if(item.name===itemName) {\r\n                                    // Update the correct component\r\n                                    if(field==='name') {\r\n                                        item.name = val;\r\n                                    }else{\r\n                                        item.amount = val;\r\n                                    }\r\n                                }\r\n                                return item;\r\n                            });\r\n                        }else{\r\n                            action.outputGroup = action.outputGroup.map(item => {\r\n                                if(item.name===itemName) {\r\n                                    if(field===\"name\") {\r\n                                        item.name = val;\r\n                                    }else{\r\n                                        item.amount = val;\r\n                                    }\r\n                                }\r\n                                return item;\r\n                            });\r\n                        }\r\n                    }\r\n                    return action;\r\n                });\r\n                // With action updates complete, we can now save the new building\r\n                props.changeSingleBuilding(workBuilding);\r\n            });\r\n    }\r\n\r\n    function newActionItem(actionName, side, itemName, amount) {\r\n        // Allows a new item to be added to a given action\r\n        // actionName - name of the action to apply the new item to\r\n        // side - use 'input' or 'output' to determine which group it is for\r\n        // itemName - name of the new item\r\n        // amount - how much of this item to be used in this action. Usually on an hourly rate\r\n\r\n        fetch(serverURL, DAX.serverMessage(\"adminNewActionItem\", {buildname: props.building.name, actionname: actionName, side:side, name:itemName, amount:amount}, true))\r\n            .then(res => DAX.manageResponseConversion(res))\r\n            .catch(err => console.log('Response error:', err))\r\n            .then(data => {\r\n                if(data.result!=='success') {\r\n                    console.log('Server reported failure:', data);\r\n                    return;\r\n                }\r\n\r\n                let workBuilding = props.building;\r\n                workBuilding.actions = workBuilding.actions.map(act => {\r\n                    if(act.name===actionName) {\r\n                        // Pick the correct side to modify\r\n                        if(side===\"input\") {\r\n                            // Account for any groups that are empty\r\n                            if(act.inputGroup===null) {\r\n                                act.inputGroup = [{name: itemName, amount:amount, isFood:0}];\r\n                            }else{\r\n                                act.inputGroup.push({name: itemName, amount:amount, isFood:0});\r\n                            }\r\n                        }else{\r\n                            if(act.outputGroup===null) {\r\n                                act.outputGroup = [{name: itemName, amount:amount, isFood:0}];\r\n                            }else{\r\n                                act.outputGroup.push({name:itemName, amount:amount, isFood:0});\r\n                            }\r\n                        }\r\n                    }\r\n                    return act;\r\n                });\r\n                props.changeSingleBuilding(workBuilding);\r\n            });\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            {/* Start with a list of available levels, and a chance to add a new level */}\r\n            <div>\r\n                <span style={{marginRight:10, fontWeight:'bold'}}>{props.building.name}</span>\r\n                <span style={{marginRight:10}}> Levels:</span>\r\n                {props.building.levels.map((ele,key) => (\r\n                    <span className=\"fakelink\" style={{marginRight:5}} key={key} onClick={()=>changeLevel(ele.devlevel)}>{ele.devlevel}</span>\r\n                ))}\r\n                <span className=\"fakelink\" onClick={addNewLevel}>+</span>\r\n            </div>\r\n\r\n            {/* Show some stats on the selected level, for the user to edit. We should have at least one of them selected*/}\r\n            <div>\r\n                Description: {/*Note that the description is not dependent on level*/}\r\n                <textarea value={description} rows={8} cols={30} onChange={(event)=>setDescription(event.target.value)} />\r\n            </div>\r\n            Workers: {\" \"}\r\n            <DanInput\r\n                fieldname=\"minWorkers\"\r\n                default={levelMinWorkers}\r\n                onUpdate={(f,val)=>setLevelMinWorkers(val)}\r\n                onBlur={()=>saveLevelStats('minworkers', levelMinWorkers)}\r\n            /> to {\" \"}\r\n            <DanInput\r\n                fieldname=\"maxworkers\"\r\n                default={levelMaxWorkers}\r\n                onUpdate={(f,val)=>setLevelMaxWorkers(val)}\r\n                onBlur={()=>saveLevelStats('maxworkers', levelMaxWorkers)}\r\n            />\r\n\r\n            {/* Now, show some information about the actions for this building */}\r\n            <div style={{fontWeight:'bold'}} >\r\n                Actions\r\n            </div>\r\n            {props.building.actions.map((ele, key) => {\r\n                if(ele!==selectedAction) {\r\n                    return <div key={key} className=\"fakelink\" onClick={()=>setSelectedAction(ele)}>{ele.name}</div>;\r\n                }else{\r\n                    return (\r\n                        <AdminAction\r\n                            key={key}\r\n                            action={ele}\r\n                            changeActionItems={changeActionItems}\r\n                            newActionItem={newActionItem}\r\n                            /*newActionItem={(action, side, name, amount)=>{\r\n                                props.newActionItem(props.building.name, action, side, name, amount);\r\n                            }}//*/\r\n                        />\r\n                    );\r\n                }\r\n            })}\r\n            <DanInput\r\n                placeholder=\"New Action Name\"\r\n                onUpdate={(f,val)=>setNewActionName(val)}\r\n                onBlur={()=>{\r\n                    // For this, we can just request a new action to be added\r\n                    if(newActionName==='') return;\r\n                    addNewAction(newActionName);\r\n                }}\r\n            />\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction AdminAction(props) {\r\n    // Handles displaying & interacting with an existing (selected) action\r\n    // prop fields - data\r\n    //      action - details about the specific action to show\r\n    // prop fields - functions\r\n    //      changeAction(newActionData) - Changes a specific action, updating the building\r\n    //      changeActionItems(actionName, 'input'/'output', 'name'/'amount', itemName, newValue) - Changes data for an item listed in this action\r\n    //      newActionItem(actionName, 'input'/'output', itemName, amount) - Adds a new item to this action\r\n    //      There are other functions needed but have not yet been built\r\n\r\n    const [minWorkers, setMinWorkers] = React.useState(props.action.minWorkers);\r\n    const [maxWorkers, setMaxWorkers] = React.useState(props.action.maxWorkers);\r\n    const [minLevel, setMinLevel] = React.useState(props.action.minLevel);\r\n    const [workerBonus, setWorkerBonus] = React.useState(props.action.workerBonus);\r\n\r\n    //let curItemName='';\r\n    //let curItemQty=0;\r\n    let working={};\r\n\r\n    return (\r\n        <div style={{border:'1px solid black', margin:10, padding:5}}>\r\n            <div style={{fontWeight:'bold'}}>{props.action.name}</div>\r\n            {/* Here would be a good place to show a description (and edit it) */}\r\n\r\n            {/* Show the basic fields for this action */}\r\n            <div>\r\n                Workers: <DanInput default={minWorkers} onUpdate={(v,val)=>setMinWorkers(val)} /> to {\" \"}\r\n                <DanInput default={maxWorkers} onUpdate={(f,val)=>setMaxWorkers(val)} />\r\n            </div>\r\n            <div>\r\n                Min Level: <DanInput default={minLevel} onUpdate={(f,val)=>setMinLevel(val)} />\r\n            </div>\r\n            <div>\r\n                Worker Bonus: <DanInput default={workerBonus} onUpdate={(f,val)=>setWorkerBonus(val)} />\r\n            </div>\r\n\r\n            {/* Now show the list of input items for this process */}\r\n            <div>\r\n                <div style={{ fontWeight:'bold'}}>Input resources:</div>\r\n                {props.action.inputGroup === null ? (\r\n                    ''\r\n                ):props.action.inputGroup.map((item,key) => (\r\n                    <div key={key}>\r\n                        Name\r\n                        <DanInput\r\n                            style={{marginRight:30}}\r\n                            fieldName={\"InExName\"+item.name}\r\n                            default={item.name}\r\n                            onFocus={()=>working={name:item.name, mode:'name', side:'input', value:item.name}}\r\n                            onUpdate={(f,v)=>working.value=v}\r\n                            onBlur={()=>{\r\n                                // While we're here, we can determine if we have actually changed the value or not\r\n                                if(working.value===undefined || item.name===working.value) return;\r\n                                console.log('For '+ item.name +' well send: ', working);\r\n                                props.changeActionItems(props.action.name, 'input', 'name', item.name, working.value)\r\n                            }}\r\n                        />\r\n                        Qty:\r\n                        <DanInput\r\n                            fieldName={\"InExAmount\"+item.name}\r\n                            default={item.amount}\r\n                            onFocus={()=>working={name:item.name, mode:'amount', side:'input', value:item.amount}}\r\n                            onUpdate={(f,v)=>working.value=v}\r\n                            onBlur={()=>{\r\n                                // While we're here, we can determine if we have actually changed the value or not\r\n                                if(working.value===undefined || item.amount===working.value) return;\r\n                                console.log('For '+ item.name +' well send: ', working);\r\n                                props.changeActionItems(props.action.name, 'input', 'amount', item.name, working.value);\r\n                            }}\r\n                        />\r\n                    </div>\r\n                ))}\r\n                {/* Allow new input items to be added */}\r\n                Name\r\n                <DanInput\r\n                    style={{marginRight:30}}\r\n                    fieldName={\"InNewName\"}\r\n                    placeholder={\"New Item Name\"}\r\n                    onUpdate={(f,v)=>working.name=v}\r\n                />\r\n                Qty:\r\n                <DanInput\r\n                    style={{marginRight:30}}\r\n                    fieldName={\"InNewAmount\"}\r\n                    default={1}\r\n                    onUpdate={(f,v)=>working.amount=v}\r\n                />\r\n                <button onClick={()=>props.newActionItem(props.action.name, 'input', working.name, working.amount)}>Add Item</button>\r\n            </div>\r\n\r\n            {/* That was a lot. Now we need to do the same for the output group */}\r\n            <div>\r\n                <div style={{fontWeight:'bold'}}>Output resources:</div>\r\n                {props.action.outputGroup===null? (''):\r\n                    props.action.outputGroup.map((item,key) => (\r\n                        <div key={key}>\r\n                            Name\r\n                            <DanInput fieldName={\"OutExName\"+item.name} default={item.name}\r\n                                onFocus={()=>working={name:item.name, mode:'name', side:'output', value:item.name}}\r\n                                onUpdate={(f,v)=>working.value=v}\r\n                                onBlur={()=>{\r\n                                    if(working.value===undefined || item.name===working.value) return;\r\n                                    props.changeActionItems(props.action.name, 'output', 'name', item.name, working.value)\r\n                                }}/>\r\n                            <span style={{marginRight:30}}></span>\r\n                            Qty:\r\n                            <DanInput fieldName={\"OutExAmount\"+item.name} default={item.amount}\r\n                                onFocus={()=>working={name:item.name, mode:'amount', side:'output', value:item.amount}}\r\n                                onUpdate={(f,v)=>working.value=v}\r\n                                onBlur={()=>{\r\n                                    if(working.value===undefined || item.amount===working.value) return;\r\n                                    props.changeActionItems(props.action.name, 'output', 'amount', item.name, working.value);\r\n                                }}\r\n                            />\r\n                        </div>\r\n                    ))\r\n                }\r\n                {/* Also allow output items to be added */}\r\n                Name\r\n                <DanInput fieldName={\"OutNewName\"} placeholder={\"New Item Name\"} onUpdate={(f,v)=>working.name=v} />\r\n                <span style={{marginRight:30}} />\r\n                Qty:\r\n                <DanInput fieldName={\"OutNewAmount\"} default={1} onUpdate={(f,v)=>working.amount=v} />\r\n                <span style={{marginRight:30}} />\r\n                <button onClick={()=>props.newActionItem(props.action.name, 'output', working.name,working.amount)}>Add Item</button>\r\n            </div>\r\n        </div>\r\n    );\r\n}","C:\\wamp\\www\\settlerswarlords\\src\\DanAjax.js",[],"C:\\wamp\\www\\settlerswarlords\\src\\block_leanto.jsx",[],"C:\\wamp\\www\\settlerswarlords\\src\\block_foragepost.jsx",[],"C:\\wamp\\www\\settlerswarlords\\src\\block_rockknapper.jsx",[],"C:\\wamp\\www\\settlerswarlords\\src\\block_toolbox.jsx",[],"C:\\wamp\\www\\settlerswarlords\\src\\game.jsx",["86"],"C:\\wamp\\www\\settlerswarlords\\src\\blockHasWorkerPriority.jsx",[],{"ruleId":"87","replacedBy":"88"},{"ruleId":"89","replacedBy":"90"},{"ruleId":"87","replacedBy":"91"},{"ruleId":"89","replacedBy":"92"},{"ruleId":"93","severity":1,"message":"94","line":6,"column":33,"nodeType":"95","messageId":"96","endLine":6,"endColumn":45},{"ruleId":"97","severity":1,"message":"98","line":81,"column":9,"nodeType":"99","messageId":"100","endLine":86,"endColumn":10},{"ruleId":"101","severity":1,"message":"102","line":64,"column":21,"nodeType":"103","messageId":"104","endLine":64,"endColumn":23},{"ruleId":"97","severity":1,"message":"98","line":428,"column":9,"nodeType":"99","messageId":"100","endLine":432,"endColumn":10},{"ruleId":"101","severity":1,"message":"102","line":504,"column":26,"nodeType":"103","messageId":"104","endLine":504,"endColumn":28},{"ruleId":"93","severity":1,"message":"105","line":75,"column":12,"nodeType":"95","messageId":"96","endLine":75,"endColumn":28},{"ruleId":"93","severity":1,"message":"106","line":75,"column":30,"nodeType":"95","messageId":"96","endLine":75,"endColumn":49},{"ruleId":"93","severity":1,"message":"107","line":64,"column":17,"nodeType":"95","messageId":"96","endLine":64,"endColumn":26},"no-native-reassign",["108"],"no-negated-in-lhs",["109"],["108"],["109"],"no-unused-vars","'buildingList' is defined but never used.","Identifier","unusedVar","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","'actionMinWorkers' is assigned a value but never used.","'setActionMinWorkers' is assigned a value but never used.","'foundFood' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]