<?php
    // ResetGame.php
    // Clears the database of current contents related to a functional game (while keeping all the static tables intact)
    // Note: Do not leave this enabled on the live server! It will easily allow random people to reset the game; there
    // is no user login for this

    //Let's die using a syntax error. But just in case...
    //die();

    include_once("server/config.php");
    include_once("server/common.php");

    DanDBList("DELETE FROM sw_error;", '', [], 'resetgame.php->clear all errors');
    DanDBList("DELETE FROM sw_event;", '', [], 'resetgame.php->clear all events');
    DanDBList("DELETE FROM sw_globals;", '', [], 'resetgame.php->clear all globals');
    DanDBList("DELETE FROM sw_knownmap;", '', [], 'resetgame.php->clear all known map tiles');
    DanDBList("DELETE FROM sw_map;", '', [], 'resetgame.php->clear all map tiles');
    DanDBList("DELETE FROM sw_minimap;", '', [], 'resetgame.php->clear all mini-map tiles');
    DanDBList("DELETE FROM sw_player;", '', [], 'resetgame.php->clear all players');
    echo('All is done');

/*
    function DanDBList($query, $varList, $vars, $codeSection) {
        // Executes a mysql query and returns the resulting data structure. A simple wrapper for the $db->query call, but includes
        // error management
        // $query - SQL query to send to the database
        // $varList - List of variable types we are providing to the database
        // $vars - array of variables to provide with the query
        // $codesection - location of the code where this was called. Instead of using line numbers, I recommend using a
        //                generalized path. For example, ajax.php->DanDBList()->function header

        global $db;
        $comm = $db->prepare($query);
        if(!$comm) {
            DanReportError('Error - statement prepare failed. DanDBList called from '. $codeSection .' with query {'. $query .'} MySQL response: '.
                           mysqli_error($db));
            return null;
        }
        if($varList!=='') {
            if(!$comm->bind_param($varList, ...$vars)) {
                DanReportError('Error - parameter binding failed. DanDBList called from '. $codeSection .' with query {'. $query .'} & params '.
                               json_encode($vars) .'. Mysql says '. mysqli_error($db));
                return null;
            }
        }
        if(!$comm->execute()) {
            DanReportError('Error - query  execution failed. DanDBList called from '. $codeSection .' with query {'. $query .'} & params '.
                           json_encode($vars) .'. Mysql says '. mysqli_error($db));
            return null;
        }
        $result = $comm->get_result();
        if(!$result) return []; // There was no data returned, so we are done here.

        $output = [];
        $content = $result->fetch_assoc();
        while($content) {
            array_push($output, $content);
            $content = $result->fetch_assoc();
        }
        return $output;
    }

    function DanReportError($errordesc) {
        // Generates an error report that is stored in the database
        // Since errors can be generated by DanDBList, we don't want to use that & result in an infinite loop, in the event that something
        // is broken.

        global $db;
        $comm = $db->prepare("INSERT INTO sw_error (happens, content) VALUES (NOW(), ?);");
        $comm->bind_param("s", $errordesc);
        $comm->execute();
    }*/
?>